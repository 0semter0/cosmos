= GnuClear =

== A New Architecture for Scalable Blockchain Decentralization ==

<pre>Jae Kwon jae@tendermint.com
Ethan Buchman ethan@tendermint.com</pre>
''NOTE: If you can read this on GitHub, then we're still actively developing this<br />
document. Please check regularly for updates.''

== Table of Contents ==

* [[#introduction|Introduction]]
* [[#tendermint|Tendermint]]
** [[#consensus|Consensus]]
** [[#light-clients|Light Clients]]
** [[#preventing-long-range-attacks|Preventing Long Range Attacks]]
** [[#overcoming-forks-and-censorship-attacks|Overcoming Forks and Censorship Attacks]]
** [[#tmsp|TMSP]]
* [[#the-gnuclear-hub-and-shards|The GnuClear Hub and Shards]]
** [[#the-gnuclear-hub|The GnuClear Hub]]
** [[#gnuclear-shards|GnuClear Shards]]
* [[#inter-blockchain-communication-ibc|Inter-blockchain Communication (IBC)]]
** [[#ibcblockcommittx-transaction|IBCBlockCommitTx Transaction]]
** [[#ibcpackettx-transaction|IBCPacketTx Transaction]]
** [[#ibc-packet-delivery-acknowledgement|IBC Packet Delivery Acknowledgement]]
* [[#use-cases|Use Cases]]
** [[#pegging-to-other-cryptocurrencies|Pegging to Other Cryptocurrencies]]
** [[#ethereum-scaling|Ethereum Scaling]]
** [[#multi-application-integration|Multi-Application Integration]]
** [[#network-partition-mitigation|Network Partition Mitigation]]
* [[#issuance-and-incentives|Issuance and Incentives]]
** [[#the-gnut-token|The Gnut Token]]
** [[#initial-gnut-distribution-and-issuance|Initial Gnut Distribution and Issuance]]
** [[#limitations-on-the-number-of-validators|Limitations on the Number of Validators]]
** [[#becoming-a-validator-after-genesis-day|Becoming a Validator After Genesis Day]]
** [[#penalties-for-validators|Penalties for Validators]]
** [[#transaction-fees|Transaction Fees]]
* [[#governance|Governance]]
** [[#parameter-change-proposal|Parameter Change Proposal]]
** [[#text-proposal|Text Proposal]]
* [[#roadmap|Roadmap]]
* [[#related-work|Related Work]]
** [[#consensus-systems|Consensus Systems]]
** [[#classic-byzantine-fault-tolerance|Classic Byzantine Fault Tolerance]]
** [[#bitshares-delegated-stake|BitShares delegated stake]]
** [[#stellar|Stellar]]
** [[#bitcoinng|BitcoinNG]]
** [[#casper|Casper]]
** [[#sharded-scaling|Sharded Scaling]]
** [[#interledger-protocol|Interledger Protocol]]
** [[#sidechains|Sidechains]]
** [[#ethereum-scalability-efforts|Ethereum Scalability Efforts]]
** [[#general-scaling|General Scaling]]
** [[#lightning-network|Lightning Network]]
** [[#segregated-witness|Segregated Witness]]
* [[#citations|Citations]]
* [[#appendix|Appendix]]
** [[#gas-fees-for-transactions|Gas Fees for Transactions]]
** [[#tmsp-specification|TMSP specification]]
** [[#merkle-tree--proof-specification|Merkle tree &amp; proof specification]]
* [[#acknowledgements|Acknowledgements]]

== Introduction ==

The combined success of the open-source ecosystem, of decentralized<br />
file-sharing, and of public cryptocurrencies, has inspired an understanding that<br />
decentralized internet protocols can be used to radically improve socio-economic<br />
infrastructure. We have seen specialized blockchain applications like Bitcoin<br />
(a cryptocurrency), ZCash (a cryptocurrency for privacy), and generalized smart<br />
contract platforms such as Ethereum, with countless distributed applications for<br />
the EVM such as Augur (a prediction market) and TheDAO (an investment club).

To date, however, these blockchains have suffered from a number of drawbacks,<br />
including their gross energy inefficiency, poor or limited performance, and<br />
immature governance mechanisms. A number of proposals have been made to scale<br />
Bitcoin's transaction throughput such as Segregated-Witness and BitcoinNG, but<br />
these are vertical scaling solutions that remain limited by the capacity of a<br />
single physical machine, lest we sacrifice the property of complete<br />
auditability. The Lightning Network can help scale Bitcoin transaction volume by<br />
leaving some transactions off the ledger completely and is well suited for<br />
micropayments and privacy preserving payment rails, but may not be suitable for<br />
more generalized scaling needs.

An ideal solution would be one that allows multiple parallel blockchains to<br />
interoperate while retaining their security properties, but this has proven<br />
difficult, if not impossible, with proof-of-work. Merged-mining, for instance,<br />
allows the work done to secure a parent chain to be re-used on a child chain,<br />
but transactions still must be validated, in order, by each node, and a<br />
merge-mined blockchain is vulnerable to attack if a majority of the hashing<br />
power on the parent is not actively merge-mining the child. An academic review<br />
of [http://vukolic.com/iNetSec_2015.pdf alternative blockchain network architectures]<br />
is provided for additional context.

Here we present GnuClear, a novel blockchain network architecture that addresses<br />
all of these problems. GnuClear is a network of many independent blockchains,<br />
called shards, that are connected by a central blockchain, called the hub. The<br />
hub and shards are powered by Tendermint Core, which provides a<br />
high-performance, consistent, secure [http://tendermint.com/blog/tendermint-vs-pbft/ PBFT-similar] consensus engine, where strict<br />
fork-accountability guarantees hold over the behaviour of malicious actors. The<br />
GnuClear hub is a simple multi-asset proof-of-stake cryptocurrency with a simple<br />
governance mechanism enabling the network to adapt and upgrade. The hub and<br />
shards of the GnuClear network communicate with each other via an<br />
inter-blockchain communication (IBC) protocol which is formalized here. The<br />
GnuClear hub utilizes IBC packets to move tokens from one shard to another while<br />
maintaining the total amount of tokens in the network, thus isolating each shard<br />
from the failure of others.

We believe that GnuClear proves that Tendermint BFT consensus is well suited for<br />
scaling public proof-of-stake blockchains, and that it can compete with<br />
proof-of-work in speed, security, and scalability. Above all, we hope it grows<br />
into a platform that works for everyone interested in distributed ledger<br />
systems.

== Tendermint ==

In this section we describe the Tendermint consensus protocol and the interface<br />
used to build applications with it.

=== Consensus ===

''NOTE: +⅔ means &quot;more than ⅔&quot;, while ⅓+ means &quot;⅓ or more&quot;.''

A fault-tolerant consensus protocol enables a set of non-faulty processes to<br />
eventually agree on a value proposed by at least one of them. The problem is<br />
made more difficult by asynchronous network conditions, wherein messages may<br />
have arbitrarily long delays, and by Byzantine faults, wherein processes may<br />
exhibit arbitrary, possibly malicious, behaviour. In particular, it is well<br />
known that deterministic consensus in asynchronous networks is impossible<br />
\cite{flp}, and that consensus protocols can tolerate strictly fewer Byzantine<br />
faults than crash faults (⅓ of processes, vs. ½). The former results from the<br />
inability to distinguish crash failures from asynchronous message delay. The<br />
latter from the fact that three processes are not enough for a safe majority<br />
vote if one of them can lie (you need at least four).

In addition to providing optimal fault tolerance, a well designed consensus<br />
protocol should provide additional guarantees in the event that the tolerance<br />
capacity is exceeded and the consensus fails. This is especially necessary in<br />
public economic systems, where Byzantine behaviour can have substantial<br />
financial reward. The most important such guarantee is a form of<br />
\emph{accountability}, where the processes that caused the consensus to fail can<br />
be identified and punished according to the rules of the protocol, or, possibly,<br />
the legal system. When the legal system is unreliable, validators can be forced<br />
to make security deposits in order to participate, and those deposits can be<br />
revoked, or slashed, when malicious behaviour is detected \cite{slasher}.

Tendermint is a Byzantine fault-tolerant (BFT) consensus protocol for<br />
asynchronous networks, notable for its simplicity, performance, and<br />
fork-accountability. The protocol requires a fixed, known set of N validators,<br />
where the ith validator is identified by its public key, V_i. Validators attempt<br />
to come to consensus on one block at a time, where a block is a list of<br />
transactions. Consensus on a block proceeds in rounds. Each round has a<br />
round-leader, or proposer, who proposes a block. The validators then vote, in<br />
stages, on whether or not to accept the proposed block or move onto the next<br />
round.

We call the voting stages PreVote and PreCommit. A vote can be for a particular<br />
block or for Nil. We call a collection of +⅔ PreVotes for a single block in the<br />
same round a Polka, and a collection of +⅔ PreCommits for a single block in the<br />
same round a Commit. If +⅔ PreCommit for Nil in the same round, they move to<br />
the next round.

The proposer at round r is simply r mod N. Note that the strict determinism<br />
incurs a weak synchrony assumption as faulty leaders must be detected and<br />
skipped. Thus, validators wait some amount TimeoutPropose before they Prevote<br />
Nil. Progression through the rest of the round is fully asychronous, in that<br />
progress is only made once a validator hears from +⅔ of the network.

An additional set of constraints, or Locking Rules, ensure that the network will<br />
eventually commit just one value. Any malicious attempt to cause more than one<br />
value to be committed can be identified. First, a PreCommit for a block must<br />
come with justification, in the form of a Polka for that block. If the validator<br />
has already PreCommit a block at round R_1, we say they are &quot;locked&quot; on that<br />
block, and the Polka used to justify the new PreCommit at round R_2 must come in<br />
a round R_polka where <code>R_1 &lt; R_polka &lt;= R_2</code>. Second, validators must Propose<br />
and/or PreVote the block they are &quot;locked&quot; on. Together, these conditions<br />
ensure that a validator does not PreCommit without sufficient evidence, and that<br />
validators which have already PreCommit cannot contribute to evidence to<br />
PreCommit something else. This ensures both safety and liveness of the<br />
consensus algorithm.

The full details of the protocol are described [https://github.com/tendermint/tmsp here].

Tendermint’s security derives simultaneously from its use of optimal Byzantine<br />
fault-tolerance and the locking mechanism. The former ensures that ⅓ or more<br />
validators must be Byzantine to cause a violation of safety, where more than two<br />
values are committed. The latter ensures that, if ever any set of validators<br />
attempts, or even succeeds, in violating safety , they can be identified by the<br />
protocol. This includes both voting for conflicting blocks and broadcasting<br />
unjustified votes.

Despite its strong guarantees, Tendermint provides exceptional performance. In<br />
benchmarks of 64 nodes distributed across 7 datacenters on 5 continents, on<br />
commodity cloud instances, Tendermint consensus can process thousands of<br />
transactions per second, with commit latencies on the order of one or two<br />
seconds. Notably, performance of well over a thousand transactions per second<br />
is maintained even in harsh adversarial conditions, with validators crashing or<br />
broadcasting maliciously crafted votes. See FIGURE for details.

=== Light Clients ===

A major benefit of Tendermint's consensus algorithm is simplified light client<br />
security, especially as compared to proof-of-work, and to protocols like Bitcoin<br />
which have no global state. Instead of syncing a chain of block headers and<br />
verifying the proof of work, light clients, who are assumed to know all public<br />
keys in the validator set, need only verify the +⅔ PreCommits in the latest<br />
block. The need to sync all block headers is eliminated as the existence of an<br />
alternative chain (a fork) means at least ⅓ of validator's deposits can be<br />
slashed. Of course, since slashing requires that ''someone'' detects the fork, it<br />
would be prudent for light clients, or at least those that are able, to sync<br />
headers, perhaps more slowly, on a risk adjusted basis, where the explicit cost<br />
of a fork can be easily calculated at at least ⅓ of the bonded stake.<br />
Additionally, light clients must stay synced with changes to the validator set,<br />
in order to avoid certain [[#preventing-long-range-attacks|long range attacks]].

In a spirit similar to Ethereum, Tendermint enables applications to embed a<br />
global Merkle root hash in each block, allowing easily verifiable state queries<br />
for things like account balances, the value stored in a contract, or the<br />
existence of an unspent transaction output, depending on the nature of the<br />
application.

=== Preventing Long Range Attacks ===

Assuming a sufficiently resilient collection of broadcast networks and a static<br />
validator set, any fork in the blockchain can be detected and the deposits of<br />
the offending validators slashed. This innovation, first suggested by Vitalik<br />
Buterin in early 2014, solves the nothing-at-stake problem of other<br />
proof-of-stake cryptocurrencies. However, since validator sets must be able to<br />
change, over a long range of time the original validators may all become<br />
unbonded, and hence would be free to create a new chain, from the genesis block,<br />
incurring no cost as they no longer have deposits locked up. This attack came<br />
to be known as the Long Range Attack (LRA) in contrast to a Short Range Attack,<br />
where validators who are currently bonded cause a fork and are hence punishable<br />
(assuming a fork-accountable BFT algorithm like Tendermint consensus). Long<br />
Range Attacks are often thought to be a critical blow to proof-of-stake.

Fortunately, the LRA can be mitigated as follows. First, for a validator to<br />
unbond, thereby recovering their deposit and no longer earning fees to<br />
participate in the consensus, the deposit must be made unavailable for an amount<br />
of time known as the &quot;unbonding period&quot;, which may be on the order of weeks or<br />
months. Second, for a light client to be secure, the first time it connects to<br />
the network it must verify a recent block-hash against a trusted source, or<br />
preferably multiple of them. This condition is sometimes referred to as &quot;weak<br />
subjectivity&quot;. Finally, to remain secure, it must sync up with the latest<br />
validator set at least as frequently as the length of the unbonding period. This<br />
ensures that the light client knows about changes to the validator set before a<br />
validator has its capital unbonded and thus no longer at stake, which would<br />
allow it to deceive the client by carrying out a long range attack by creating<br />
new blocks beginning back at a height where it was bonded (assuming it had<br />
sufficient validating power then!).

Note that overcoming the LRA in this way requires a practical tweak of the<br />
original security model of proof-of-work. In PoW, it is assumed that a light<br />
client can sync to the current height from the trusted genesis block at any time<br />
simply by processing the proof-of-work in every block header. To overcome the<br />
LRA, however, we require that a light client come online with some regularity,<br />
and that the first time they come online they must be particularly careful to<br />
authenticate what they hear from the network against trusted sources. Of course,<br />
this latter requirement is similar to that of Bitcoin, where the protocol and<br />
software must also be obtained from a trusted source.

The above method for prevent LRA is well suited for validators and full nodes of<br />
a Tendermint-powered blockchain because these nodes are meant to remain<br />
connected to the network. The method is also suitable for light clients that<br />
can be expected to sync with the network frequently. However, for light clients<br />
that are not expected to have frequent access to the internet or the blockchain<br />
network, yet another solution can be used to overcome the LRA. Non-validator<br />
token holders can post their tokens as collateral with a very long unbonding<br />
period (e.g. much longer than the unbonding period for validators) and serve<br />
light clients with a secondary method of attesting to the validity of current<br />
and past block-hashes. While these tokens do not count toward the security of<br />
the blockchain's consensus, they nevertheless can provide strong guarantees for<br />
light clients. If historical block-hash querying are supported in Ethereum,<br />
anyone could bond their tokens in a specially designed smart contract and<br />
provide attestation services for pay, effectively creating a market for<br />
light-client LRA security.

=== Overcoming Forks and Censorship Attacks ===

Due to the definition of a block commit, any ⅓+ coalition of validators can<br />
halt the blockchain by not broadcasting their votes. Such a coalition can also<br />
censor particular transactions by rejecting blocks that include these<br />
transactions, though this would result in a significant proportion of block<br />
proposals to be rejected, which would slow down the rate of block commits of the<br />
blockchain, reducing its utility and value. The malicious coalition might also<br />
broadcast votes in a trickle so as to grind blockchain block commits to a near<br />
halt, or engage in any combination of these attacks. Finally, it can cause the<br />
blockchain to fork, by double-signing or violating the locking rules.

If a global active adversary were also involved, it can partition the network<br />
in such a way that it may appear that the wrong subset of validators were<br />
responsible for the slowdown. This is not just a limitation of Tendermint, but<br />
rather a limitation of all consensus protocols whose network is potentially<br />
controlled by an active adversary.

For these types of attacks, a subset of the validators through external means<br />
should coordinate to sign a reorg-proposal that chooses a fork (and any evidence<br />
thereof) and the initial subset of validators with their signatures. Clients<br />
should verify the signatures on the reorg-proposal, verify any evidence, and<br />
make a judgement or prompt the end-user for a decision. For example, a phone<br />
wallet app may prompt the user with a security warning, while a refrigerator may<br />
accept any reorg-proposal signed by +½ of the original validators. If we further<br />
require that validators who sign such a reorg-proposal forego its collateral on<br />
all other forks, light-clients can be assured by up to ⅙ of the bonded<br />
collateral (⅙ == ⅔ - ½). Notice that no Byzantine fault-tolerant algorithm can<br />
come to consensus when ⅓+ of validators are dishonest, yet a fork assumes that<br />
⅓+ of validators have been dishonest by double-signing or lock-changing without<br />
justification. So, signing the reorg- proposal is a coordination problem that<br />
cannot be solved internally by any protocol -- not even Tendermint. It must be<br />
provided externally.

Assuming that the external coordination medium and protocol is robust, it<br />
follows that forks are less of a concern than censorship attacks.

In addition to forks and censorship, which require ⅓+ Byzantine validators, a<br />
coalition of +⅔ validators may commit arbitrary, invalid state. This is<br />
characteristic of any (BFT) consensus system. Unlike double-signing, which<br />
creates forks with easily verifiable evidence, detecting committment of an<br />
invalid state requires non-validating peers to verify whole blocks, which<br />
implies that they keep a local copy of the state and execute each transaction,<br />
computing the state root independently for themselves. Once detected, the only<br />
way to handle such a failure is via social consensus on alternative media. For<br />
instance, in situations where Bitcoin has failed, whether forking due to<br />
software bugs (as in March 2013), or committing invalid state due to Byzantine<br />
behavior of miners (as in the July 2016), the well connected community of<br />
businesses, developers, miners, and other organizations established a social<br />
consensus as to what manual actions were required by participants to heal the<br />
network. Furthermore, since validators of a Tendermint blockchain may be<br />
expected to be identifiable, commitment of an invalid state may even be<br />
punishable by law or some external jurisprudence, if desired.

=== TMSP ===

The Tendermint consensus algorithm is implemented in a program called Tendermint<br />
Core. Tendermint Core is an application-agnostic &quot;consensus engine&quot; that can<br />
turn any deterministic (blackbox) application into a distributedly replicated<br />
blockchain. As the Apache Web Server or Nginx connects to the Wordpress<br />
application via CGI or FastCGI, Tendermint Core connects to blockchain<br />
applications via TMSP. Thus, TMSP allows for blockchain applications to be<br />
programmed in any language, not just the programming language that the consensus<br />
engine is written in. Additionally, TMSP makes it possible to easily swap out<br />
the consensus layer of any existing blockchain stack.

To draw an analogy, we will draw an analogy with a well-known cryptocurrency,<br />
Bitcoin. Bitcoin is a cryptocurrency blockchain where each node maintains a<br />
fully audited Unspent Transaction Output (UTXO) database. If one wanted to<br />
create a Bitcoin-like system on top of TMSP, Tendermint Core would be<br />
responsible for

* Sharing blocks and transactions between nodes
* Establishing a canonical/immutable order of transactions (the blockchain)

Meanwhile, the TMSP application would be responsible for

* Maintaining the UTXO database
* Validating cryptographic signatures of transactions
* Preventing transactions from spending non-existent transactions
* Allowing clients to query the UTXO database.

Tendermint is able to decompose the blockchain design by offering a very simple<br />
API between the application process and consensus process.

TMSP consists of 3 primary message types that get delivered from the core to<br />
the application. The application replies with corresponding response messages.

The <code>AppendTx</code> message is the work horse of the application. Each transaction in<br />
the blockchain is delivered with this message. The application needs to validate<br />
each transactions received with the AppendTx message against the current state,<br />
application protocol, and the cryptographic credentials of the transaction. A<br />
validated transaction then needs to update the application state — by binding a<br />
value into a key values store, or by updating the UTXO database.

The <code>CheckTx</code> message is similar to AppendTx, but it’s only for validating<br />
transactions. Tendermint Core’s mempool first checks the validity of a<br />
transaction with CheckTx, and only relays valid transactions to its peers.<br />
Applications may check an incrementing nonce in the transaction and return an<br />
error upon CheckTx if the nonce is old.

The <code>Commit</code> message is used to compute a cryptographic commitment to the<br />
current application state, to be placed into the next block header. This has<br />
some handy properties. Inconsistencies in updating that state will now appear as<br />
blockchain forks which catches a whole class of programming errors. This also<br />
simplifies the development of secure lightweight clients, as Merkle-hash proofs<br />
can be verified by checking against the block-hash, and the block-hash is signed<br />
by a quorum of validators.

Additional TMSP messages allow the application to keep track of and change the<br />
validator set, and for the application to receive the block information, such as<br />
the height and the commit votes. The full TMSP specification can be found<br />
[https://github.com/tendermint/tmsp#message-types here].

== The GnuClear Hub and Shards ==

Here we describe a novel model of decentralization and scalability. GnuClear is<br />
a network of many blockchains powered by Tendermint via TMSP. While existing<br />
proposals aim to create a &quot;single blockchain&quot; with total global transaction<br />
ordering, GnuClear permits many blockchains to run concurrently with one another<br />
via a sharding mechanism.

At the basis, a global hub blockchain (the GnuClear hub) manages many<br />
independent blockchain shards. A constant stream of recent block commits from<br />
shards posted on the hub allows the hub to keep up with the state of each shard.<br />
Likewise, each shard keeps up with the state of the hub (but shards do not keep<br />
up with each other except indirectly through the hub). Packets of information<br />
are then communicated from one chain to another by posting Merkle-proofs that<br />
collide with a recent block-hash from the source. This mechanism is called<br />
inter-blockchain communication, or IBC for short.

(Diagram of hub and shards)

Any of the shards can themselves be hubs to form a multi-level hierarchical<br />
network, but for the sake of clarity we will only describe the simple<br />
configuration with one central hub and many shards.

=== The GnuClear Hub ===

The GnuClear hub is a blockchain that hosts a multi-asset cryptocurrency, where<br />
tokens can be held by individual users or by shards themselves. These tokens<br />
can be moved from one shard to another in a special IBC packet called a &quot;coin<br />
packet&quot;. The hub is responsible for preserving the global invariance of the<br />
total amount of each token across the shards. IBC coin packet transactions must<br />
be committed by the sender, hub and reciever blockchains.

Since the GnuClear hub acts as a central ledger of tokens for the whole system,<br />
the security of the hub is of paramount importance. While each shard may be a<br />
Tendermint blockchain that is secured by as few as 4 (or even less if BFT<br />
consensus is not needed), the hub must be secured by a globally decentralized<br />
set of validators that can withstand the most severe attack scenarios, such as a<br />
continental network partition or a nation-state sponsored attack.

=== GnuClear Shards ===

A GnuClear shard is an independent blockchain that exchanges IBC messages with<br />
the Hub. From the Hub's perspective, a shard is a multi-asset account that can<br />
send and receive tokens using IBC packets. Like a cryptocurrency account, a<br />
shard cannot transfer more tokens than it has, but can receive tokens from<br />
others who have them. In certain cases, a shard may be granted special<br />
priveleges to act as a &quot;source&quot; of some token, where, in addition to the shard's<br />
balance in that token, it can send up to some maximum rate of additional tokens<br />
out to other accounts or shards, thereby inflating that token's supply. Such<br />
packets are similar to the &quot;coin&quot; packet, but have type &quot;issue&quot;. Packets of type<br />
&quot;issue&quot; for a particular token may originate from only one shard - that is,<br />
there may be only one priveleged shard per token type. On Genesis day, a select<br />
number of priveleged shards will be created to act as pegs to other<br />
cryptocurrencies. The creation of new priviledged shards is left to governance.

Note that a shard where +⅔ of the validators are Byzantine can commit invalid<br />
state. Since the very purpose of the GnuClear hub is to avoid verifying every<br />
transaction on a shard, detecting such failures must be done by independent<br />
observers of the shard, which may appeal to social media and to the market to<br />
make their detection known (for instance, selling/shorting a token that is being<br />
artificially inflated by a Byzantine source-shard, and writing a blog post about<br />
the attack). Additionally, if the validator set of the shard is not the same as<br />
that of the hub, and shard validators have stake bonded on the hub, an explicit<br />
alert mechanism may be used on the hub to challenge the validity of a block and<br />
to slash the deposits of offending validators.

== Inter-blockchain Communication (IBC) ==

Now we look at how the hub and shards communicate with each other. Say that<br />
there are three blockchains, &quot;Shard1&quot;, &quot;Shard2&quot;, and &quot;Hub&quot;, and we wish for<br />
&quot;Shard1&quot; to produce a packet destined for &quot;Shard2&quot; going through &quot;Hub&quot;. For a<br />
packet to move from one blockchain to another, a proof must be posted on the<br />
receiving chain that the sending chain knows about a packet with the appropriate<br />
destination. For the receiving chain to check the proof, it must keep up with<br />
the sender's block headers. The mechanism is similar to that used by<br />
sidechains, requiring two interacting chains to &quot;be aware&quot; of one another.

The IBC protocol can therefore naturally be defined using two types of<br />
transaction: an <code>IBCBlockCommitTx</code> transaction, which allows a blockchain to<br />
notify another of its most recent block-hash, and an <code>IBCPacketTx</code> transaction,<br />
which allows a sender blockchain to prove to a receiver blockchain that a packet<br />
destined for the receiver was was included in a recent state of the sender. The<br />
proof depends on the receiver having received a recent block-hash via an<br />
<code>IBCBlockCommitTx</code>.

By splitting the IBC mechanics into two separate transactions <code>IBCBlockCommitTx</code><br />
and <code>IBCPacketTx</code>, we allow the native fee market-mechanism of the receiving<br />
chain to determine which packets get committed (i.e. acknowledged), while<br />
allowing for complete freedom on the sending chain as to how many outbound<br />
packets are allowed.

[[File:https://raw.githubusercontent.com/gnuclear/gnuclear-whitepaper/master/msc/ibc_without_ack.png|Figure of Shard1, Shard2, and Hub IBC without<br />
acknowledgement]]

<CAPTION on a figure>
In the example above, in order to update the block-hash of &quot;Shard1&quot; on &quot;Hub&quot; (or<br />
of &quot;Hub&quot; on &quot;Shard2&quot;), an <code>IBCBlockCommitTx</code> transaction must be posted on &quot;Hub&quot;<br />
with the block-hash of &quot;Shard1&quot; (or on &quot;Shard2&quot; with the block-hash of &quot;Hub&quot;).

=== IBCBlockCommitTx Transaction ===

An <code>IBCBlockCommitTx</code> transaction is composed of:

* <code>ChainID (string)</code>: The ID of the blockchain
* <code>BlockHash ([]byte)</code>: The block-hash bytes, the Merkle root which includes the<br />
app-hash
* <code>BlockPartsHeader (PartSetHeader)</code>: The block part-set header bytes, only<br />
needed to verify vote signatures
* <code>BlockHeight (int)</code>: The height of the commit
* <code>BlockRound (int)</code>: The round of the commit
* <code>Commit ([]Vote)</code>: The +⅔ Tendermint <code>Precommit</code> votes that comprise a block<br />
commit
* <code>ValidatorsHash ([]byte)</code>: A Merkle-tree root hash of the new validator set
* <code>ValidatorsHashProof (SimpleProof)</code>: A SimpleTree Merkle-proof for proving the<br />
<code>ValidatorsHash</code> against the <code>BlockHash</code>
* <code>AppHash ([]byte)</code>: A IAVLTree Merkle-tree root hash of the application state
* <code>AppHashProof (SimpleProof)</code>: A SimpleTree Merkle-proof for proving the<br />
<code>AppHash</code> against the <code>BlockHash</code>

=== IBCPacketTx Transaction ===

An <code>IBCPacket</code> is composed of:

* <code>Header (IBCPacketHeader)</code>: The packet header
* <code>Payload ([]byte)</code>: The bytes of the packet payload. ''Optional''
* <code>PayloadHash ([]byte)</code>: The hash for the bytes of the packet. ''Optional''

Either one of <code>Payload</code> or <code>PayloadHash</code> must be present. The hash of an<br />
<code>IBCPacket</code> is a simple Merkle root of the two items, <code>Header</code> and <code>Payload</code>.<br />
An <code>IBCPacket</code> without the full payload is called an ''abbreviated packet''.

An <code>IBCPacketHeader</code> is composed of:

* <code>SrcChainID (string)</code>: The source blockchain ID
* <code>DstChainID (string)</code>: The destination blockchain ID
* <code>Number (int)</code>: A unique number for all packets
* <code>Status (enum)</code>: Can be one of <code>AckPending</code>, <code>AckSent</code>, <code>AckReceived</code>,<br />
<code>NoAck</code>, or <code>Timeout</code>
* <code>Type (string)</code>: The types are application-dependent. GnuClear reserves the<br />
&quot;coin&quot; packet type
* <code>MaxHeight (int)</code>: If status is not <code>NoAckWanted</code> or <code>AckReceived</code> by this<br />
height, status becomes <code>Timeout</code>. ''Optional''

An <code>IBCPacketTx</code> transaction is composed of:

* <code>FromChainID (string)</code>: The ID of the blockchain which is providing this<br />
packet; not necessarily the source
* <code>FromBlockHeight (int)</code>: The blockchain height in which the following packet<br />
is included (Merkle-ized) in the block-hash of the source chain
* <code>Packet (IBCPacket)</code>: A packet of data, whose status may be one of<br />
<code>AckPending</code>, <code>AckSent</code>, <code>AckReceived</code>, <code>NoAck</code>, or <code>Timeout</code>
* <code>PacketProof (IAVLProof)</code>: A IAVLTree Merkle-proof for proving the packet's<br />
hash against the <code>AppHash</code> of the source chain at given height

The sequence for sending a packet from &quot;Shard1&quot; to &quot;Shard2&quot; through the &quot;Hub&quot; is<br />
depicted in {Figure X}. First, an <code>IBCPacketTx</code> proves to &quot;Hub&quot; that the packet<br />
is included in the app-state of &quot;Shard1&quot;. Then, another <code>IBCPacketTx</code> proves to<br />
&quot;Shard2&quot; that the packet is included in the app-state of &quot;Hub&quot;. During this<br />
procedure, the <code>IBCPacket</code> fields are identical: the <code>SrcChainID</code> is always<br />
&quot;Shard1&quot;, and the <code>DstChainID</code> is always &quot;Shard2&quot;.

The <code>PacketProof</code> must have the correct Merkle-proof path, as follows:

<pre>IBC/&lt;SrcChainID&gt;/&lt;DstChainID&gt;/&lt;Number&gt;
</pre>
TODO: CLARIFY

When &quot;Shard1&quot; wants to send a packet to &quot;Shard2&quot; through &quot;Hub&quot;, the <code>IBCPacket</code><br />
data are identical whether the packet is Merkle-ized on &quot;Shard1&quot;, the &quot;Hub&quot;, or<br />
&quot;Shard2&quot;. The only mutable field is <code>Status</code> for tracking delivery, as shown<br />
below.

=== IBC Packet Delivery Acknowledgement ===

There are several reasons why a sender may want the acknowledgement of delivery<br />
of a packet by the receiving chain. For example, the sender may not know the<br />
status of the destination chain, if it is expected to be faulty. Or, the sender<br />
may want to impose a timeout on the packet (with the <code>MaxHeight</code> packet field),<br />
while any destination chain may suffer from a denial-of-service attack with a<br />
sudden spike in the number of incoming packets.

In these cases, the sender can require delivery acknowledgement by setting the<br />
initial packet status to <code>AckPending</code>. Then, it is the receiving chain's<br />
responsibility to confirm delivery by including an abbreviated<code>IBCPacket</code> in the<br />
app Merkle hash.

[[File:https://raw.githubusercontent.com/gnuclear/gnuclear-whitepaper/master/msc/ibc_with_ack.png|Figure of Shard1, Shard2, and Hub IBC with<br />
acknowledgement]]

First, an <code>IBCBlockCommit</code> and <code>IBCPacketTx</code> are posted on &quot;Hub&quot; that proves the<br />
existence of an <code>IBCPacket</code> on &quot;Shard1&quot;. Say that <code>IBCPacketTx</code> has the<br />
following value:

* <code>FromChainID</code>: &quot;Shard1&quot;
* <code>FromBlockHeight</code>: 100 (say)
* <code>Packet</code>: an <code>IBCPacket</code>:
* <code>Header</code>: an <code>IBCPacketHeader</code>:
** <code>SrcChainID</code>: &quot;Shard1&quot;
** <code>DstChainID</code>: &quot;Shard2&quot;
** <code>Number</code>: 200 (say)
** <code>Status</code>: <code>AckPending</code>
** <code>Type</code>: &quot;coin&quot;
** <code>MaxHeight</code>: 350 (say &quot;Hub&quot; is currently at height 300)
* <code>Payload</code>: &lt;The bytes of a &quot;coin&quot; payload&gt;

Next, an <code>IBCBlockCommit</code> and <code>IBCPacketTx</code> are posted on &quot;Shard2&quot; that proves<br />
the existence of an <code>IBCPacket</code> on &quot;Hub&quot;. Say that <code>IBCPacketTx</code> has the<br />
following value:

* <code>FromChainID</code>: &quot;Hub&quot;
* <code>FromBlockHeight</code>: 300
* <code>Packet</code>: an <code>IBCPacket</code>:
* <code>Header</code>: an <code>IBCPacketHeader</code>:
** <code>SrcChainID</code>: &quot;Shard1&quot;
** <code>DstChainID</code>: &quot;Shard2&quot;
** <code>Number</code>: 200
** <code>Status</code>: <code>AckPending</code>
** <code>Type</code>: &quot;coin&quot;
** <code>MaxHeight</code>: 350
* <code>Payload</code>: &lt;The same bytes of a &quot;coin&quot; payload&gt;

Next, &quot;Shard2&quot; must include in its app-hash an abbreviated packet that shows the<br />
new status of <code>AckSent</code>. An <code>IBCBlockCommit</code> and <code>IBCPacketTx</code> are posted back<br />
on &quot;Hub&quot; that proves the existence of an abbreviated <code>IBCPacket</code> on &quot;Shard2&quot;.<br />
Say that <code>IBCPacketTx</code> has the following value:

* <code>FromChainID</code>: &quot;Shard2&quot;
* <code>FromBlockHeight</code>: 400 (say)
* <code>Packet</code>: an <code>IBCPacket</code>:
* <code>Header</code>: an <code>IBCPacketHeader</code>:
** <code>SrcChainID</code>: &quot;Shard1&quot;
** <code>DstChainID</code>: &quot;Shard2&quot;
** <code>Number</code>: 200
** <code>Status</code>: <code>AckSent</code>
** <code>Type</code>: &quot;coin&quot;
** <code>MaxHeight</code>: 350
* <code>PayloadHash</code>: &lt;The hash bytes of the same &quot;coin&quot; payload&gt;

Finally, &quot;Hub&quot; must update the status of the packet from <code>AckPending</code> to<br />
<code>AckReceived</code>. Evidence of this new finalized status should go back to<br />
&quot;Shard2&quot;. Say that <code>IBCPacketTx</code> has the following value:

* <code>FromChainID</code>: &quot;Hub&quot;
* <code>FromBlockHeight</code>: 301
* <code>Packet</code>: an <code>IBCPacket</code>:
* <code>Header</code>: an <code>IBCPacketHeader</code>:
** <code>SrcChainID</code>: &quot;Shard1&quot;
** <code>DstChainID</code>: &quot;Shard2&quot;
** <code>Number</code>: 200
** <code>Status</code>: <code>AckReceived</code>
** <code>Type</code>: &quot;coin&quot;
** <code>MaxHeight</code>: 350
* <code>PayloadHash</code>: &lt;The hash bytes of the same &quot;coin&quot; payload&gt;

Meanwhile, &quot;Shard1&quot; may optimistically assume successful delivery of a &quot;coin&quot;<br />
packet unless evidence to the contrary is proven on &quot;Hub&quot;. In the example<br />
above, if &quot;Hub&quot; had not received an <code>AckSent</code> status from &quot;Shard2&quot; by block 350,<br />
it would have set the status automatically to <code>Timeout</code>. This evidence of a<br />
timeout can get posted back on &quot;Shard1&quot;, and any tokens can be returned.

[[File:https://raw.githubusercontent.com/gnuclear/gnuclear-whitepaper/master/msc/ibc_with_ack_timeout.png|Figure of Shard1, Shard2, and Hub IBC with acknowledgement and<br />
timeout]]

== Use Cases ==

=== Pegging to Other Cryptocurrencies ===

A priveleged shard can act as the source of a pegged token of another<br />
cryptocurrency. A peg is in essence similar to the relationship between a<br />
GnuClear hub and shard; both must keep up with the latest blocks of the<br />
other in order to verify proofs that tokens have moved from one to the other. A<br />
peg-shard on the GnuClear network keeps up with both the hub as well as the<br />
other cryptocurrency. The indirection through the peg-shard allows the logic of<br />
the hub to remain simple by encapsulating any non-Tendermint consensus<br />
light-client verification logic onto the shard.

For instance, a GnuClear shard with some validator set, possibly the same as<br />
that of the hub, could act as an ether-peg, where the TMSP-application on the<br />
shard (the &quot;peg-shard&quot;) has mechanisms to exchange IBC messages with a<br />
peg-contract on the external Ethereum blockchain (the &quot;target&quot;). This contract<br />
would allow ether holders to send ether to the peg-shard by sending it to the<br />
peg-contract on Ethereum. Once ether is received by the peg-contract, the ether<br />
cannot be withdrawn unless an appropriate IBC packet is received by the<br />
peg-contract from the peg-shard. When a peg-shard receives an IBC packet proving<br />
that ether was received in the peg-contract for a particular Ethereum account, a<br />
corresponding account is created on the peg-shard with that balance. Ether on<br />
the peg-shard (&quot;pegged-ether&quot;) can then be transferred to and from the hub, and<br />
later be destroyed with a transaction that sends it to a particular withdrawal<br />
address on Ethereum; an IBC packet proving that the transaction occured on the<br />
peg-shard can be posted to the Ethereum peg-contract to allow the ether to be<br />
withdrawn.

Of course, the risk of such a pegging contract is a rogue validator set. ⅓+<br />
Byzantine validators could cause a fork, withdrawing ether from the peg-contract<br />
on Ethereum while keeping the pegged-ether on the peg-shard. Worse, +⅔<br />
Byzantine validators can steal ether outright from those who sent it to the<br />
peg-contract by deviating from the original pegging logic of the peg-shard.

It is possible to address these issues by designing the peg to be &quot;totally<br />
accountable&quot;. For example, all IBC packets both from the hub as well as from<br />
the target might require acknowledgement by the peg-shard in such a way that all<br />
state transitions of the peg-shard can be efficiently challenged and verified by<br />
either the hub or the target. The hub and the target (or in the case of<br />
Ethereum, the peg-contract) should allow the peg-shard validators to post<br />
collateral, and token transfers out of the peg-contract should be delayed (and<br />
collateral unbonding period sufficiently long) to allow for any challenges to be<br />
made. We leave the design of the specification and implementation of this<br />
system open as a future GnuClear improvement proposal.

While the socio-political atmosphere is not quite evolved enough yet, we can<br />
extend the mechanism to allow for shards which peg to the fiat currency of a<br />
nation states by forming a validator set out of some combination of institutions<br />
responsible for the nation's currency, most particularly, its banks. Of course,<br />
extra precautions must be made to only accept currencies backed by strong legal<br />
systems that can enforce auditability of the banks' activities by a sufficiently<br />
large group of trusted notaries and institutions.

A result of this integration would be, for instance, the ability of anyone with<br />
a bank account at a participating bank to move dollars from their bank account,<br />
which is on the shard, to other accounts on the shard, or to the hub, or to<br />
another shard entirely. In this regard, GnuClear can act as a seamless conduit<br />
between fiat currencies and cryptocurrencies.

=== Ethereum Scaling ===

An open issue for Ethereum is how to solve the scaling problem. Currently,<br />
Ethereum nodes process every single transaction and also stores all the state.<br />
[https://docs.google.com/presentation/d/1CjD0W4l4-CwHKUvfF5Vlps76fKLEC6pIwu1a_kC_YRQ/mobilepresent?slide=id.gd284b9333_0_28 link].

Since Tendermint can commit blocks much faster than Ethereum's proof-of-work,<br />
EVM shards powered by Tendermint consensus and operating on pegged-ether can<br />
provide higher performance to Ethereum blockchains. Additionally, though the<br />
GnuClear hub and IBC packet mechanics does not allow for arbitrary contract<br />
logic execution per se, it can be used to co-ordinate Ethereum contracts running<br />
on different shards, providing a foundation for generalized Ethereum scaling via<br />
sharding. For example, asynchronous contract calls that &quot;send an action&quot; and<br />
expect a response in return could be implemented by a sequence of two IBC<br />
packets going in opposite directions.

=== Multi-Application Integration ===

GnuClear shards run arbitrary application logic, defined at the beginning of the<br />
shard's life, and potentially updated over time by governance. Such flexibility<br />
allows GnuClear shards to act as pegs to other cryptocurrencies, like Ethereum<br />
or Bitcoin, but it also permits derlivatives of those blockchains, utilizing the<br />
same codebase but a different validator set and history. This allows many<br />
existing cryptocurrency frameworks, such as that of Ethereum, ZCash, Bitcoin,<br />
CryptoNote, and so on to be used with a higher performance consensus engine on a<br />
common network, openning tremendous opportunity for interoperability across<br />
platforms. Furthermore, as a multi-asset blockchain, a single transaction may<br />
contain multiple inputs and outputs, where each input can be any token type,<br />
enabling GnuClear to serve directly as a platform for decentralized exchange,<br />
though orders are assumed to be matched via other platforms. Alternatively, a<br />
shard can serve as a fault-tolerant exchange, including hosting the orderbook,<br />
openning up new business opportunities for blockchain backed exchanges, which<br />
may themselves trade liquidity over the GnuClear network.

Shards can also serve as blockchain-backed versions of enterprise and government<br />
systems, where pieces of a particular service, traditionally run by an<br />
organization or group of organizations, are instead run as a TMSP application on<br />
a certain shard, allowing it to inherit the security and interoperability of the<br />
public GnuClear network, without sacrificing control over the underlying<br />
service. Thus, GnuClear may be a best of both worlds for organizations looking<br />
to utilize blockchain technology that are wary of relinquishing control to an<br />
unidentified set of miners.

=== Network Partition Mitigation ===

A major problem with consistency favouring consensus algorithms like Tendermint<br />
is thought to be that any network partition which causes there to be no single<br />
partition with +⅔ validators will halt consensus altogether. The GnuClear<br />
architecture can mitigate this problem by using a global hub with regional<br />
autonomous shards, where +⅔ validators in a shard are based in a common<br />
geographic region. For instance, a common paradigm may be for individual cities,<br />
or regions, to operate a given shard for the coordination of finances and<br />
infrastructure, enabling municipal activity to persist in the event that<br />
otherwise remote service providers fail. Note that this allows real geological,<br />
political, and network-topological features to be considered in designing robust<br />
federated fault-tolerant systems.

== Issuance and Incentives ==

=== The Gnut Token ===

While the GnuClear hub is a multi-asset system, there is a native token called<br />
''gnuts''. Unlike Ethereum's ether or Bitcoin's bitcoins, GnuClear's gnuts are<br />
meant for staking by validators, and voting on proposals to improve and maintain<br />
the GnuClear network. To discourage the use of gnuts as a store-of-wealth or<br />
means of exchange, gnuts that are not held in bond decay at a rate of<br />
<code>GnutDecay</code> (DEFAULT: a half-life of 5 years). Gnut holders who do not wish to<br />
validate, or cannot because they do not meet the bonding threshold can delegate<br />
to any combination of existing validators. Gnut holders who delegate to<br />
validators do not pay the decay penalty.

=== Initial Gnut Distribution and Issuance ===

The initial distribution of gnut tokens and validators on Genesis will be<br />
composed of a list of publicly identifiable validators who have already<br />
contributed toward cryptocurrency, blockchain, and distributed systems research<br />
and praxis, including research groups, nonprofit foundations, and exchanges.<br />
These genesis validators will be incentivized to continue validating, by virtue<br />
of a vesting schedule. All of the initial bonded gnuts of the validators on<br />
genesis day will vest on a block-by-block basis over a period of 4 years.<br />
Unvested gnuts can be used to the full extent for voting, but disappears after<br />
unbonding. It follows that gnuts cannot be transferred until vested. There<br />
will be a total of 67 total validator spots with 200,000 vesting gnuts each,<br />
where each validating entity may be allocated one or more validator spots.

In addition to the 67 * 200,000 vesting gnuts by the genesis validators, there<br />
will also be 21,474 gnuts that are issued through Bitcoin every week for 52*6<br />
weeks. Bitcoin accounts that send bitcoins to either the <code>GnuClearBurnAddress</code><br />
or <code>GnuClearFoundationAddress</code> will receive the 21474 gnuts in proportion to the<br />
amount of bitcoins burned or donated.

=== Limitations on the Number of Validators ===

Unlike Bitcoin or other proof-of-work blockchains, a Tendermint blockchain gets<br />
slower with more validators due to the increased communication complexity.<br />
Fortunately, we can support enough validators to make for a robust globally<br />
distributed blockchain with very fast blocktimes, and, as bandwidth, storage,<br />
and parallel compute capacity increases, we will be able to support more<br />
validators in the future.

On genesis day, the maximum number of validators will be set to 100, and this<br />
number will increase at a rate of 13% for 10 years, and settle at 300<br />
validators.

<pre>Year 0: 100
Year 1: 113
Year 2: 127
Year 3: 144
Year 4: 163
Year 5: 184
Year 6: 208
Year 7: 235
Year 8: 265
Year 9: 300
Year 10: 300
...</pre>
=== Becoming a Validator After Genesis Day ===

Gnut holders who are not already validators can become one by signing and<br />
submitting a <code>BondTx</code> transaction. The amount of gnuts provided as<br />
collateral must be nonzero. Anyone can become a validator at any<br />
time, except when the size of the current validator set is greater than the<br />
maximum number of validators allowed. In that case, the transaction is only<br />
valid if the amount of gnuts is greater than the amount of effective gnuts held<br />
by the smallest validator, where effective gnuts include vesting and delegated<br />
gnuts. When a new validator replaces an existing validator in such a way, the<br />
existing validator becomes inactive and all the gnuts and delegated gnuts enter<br />
the unbonding state. Note that, given the distribution of genesis validators,<br />
the 33 available validator spots, and the issuance schedule, it is impossible<br />
for any genesis validators to become unbonded by this mechanism.

=== Penalties for Validators ===

There must be some penalty imposed on the validators for when they intentionally<br />
or unintentionally deviate from the sanctioned protocol. Some evidence is<br />
immediately admissible, such as a double-sign at the same height and round, or a<br />
violation of &quot;prevote-the-lock&quot; (a violation of the Tendermint consensus<br />
protocol). Such evidence will result in the validator losing its good standing<br />
and its bonded gnu tokens as well its proportionate share of tokens in the<br />
reserve pool -- collectively called its &quot;stake&quot; -- will get slashed.

Sometimes, validators will not be available, either due to regional network<br />
disruptions, power failure, or other reasons. If, at any point in the past<br />
<code>ValidatorTimeoutWindow</code> blocks, a validator's commit vote is not included in<br />
the blockchain more than <code>ValidatorTimeoutMaxAbsent</code> times, that validator will<br />
become inactive, and lose <code>ValidatorTimeoutPenalty</code> (DEFAULT 1%) of its stake.

Some &quot;malicious&quot; behavior do not produce obviously discernable evidence on the<br />
blockchain. In these cases, the validators can coordinate out of band to force<br />
the timeout of these malicious validators, if there is a supermajority<br />
consensus.

In situations where the GnuClear hub halts due to a ⅓+ coalition of validators<br />
going offline, or in situations where a ⅓+ coalition of validators censor<br />
evidence of malicious behavior from entering the blockchain, as long as there<br />
are -½ such Byzantine validators, the hub will recover with a reorg-proposal.<br />
(Link to &quot;Forks and Censorship Attacks&quot;).

=== Transaction Fees ===

GnuClear validators can accept any token type or combination of types as a fee<br />
for processing a transaction. Each validator can subjectively set whatever<br />
exchange rate it wants, and choose whatever transactions it wants, as long as<br />
the <code>BlockGasLimit</code> is not exceeded. The collected fees minus any taxes<br />
specified below are redistributed to the holders of bonded gnu tokens,<br />
proportionately, every <code>ValidatorPayoutPeriod</code> blocks.

Of the collected transaction fees, <code>ReserveTaxRatio</code> (DEFAULT 2%) will go toward<br />
the reserve pool to increase the reserve pool and increase the security and<br />
value of the GnuCler network. Also, a <code>CommonsTaxRatio</code> (DEFAULT 3%) will go<br />
toward the funding of common goods. These funds will go to the<br />
<code>CustodianAddress</code> to be distributed in accordance with whatever is decided by<br />
the governance system.

Gnut holders who delegate their voting power to other validators pay<br />
<code>DelegationCommision</code> (DEFAULT 15%) to the delegated validator.

== Governance ==

The GnuClear hub blockchain is a distributed organization that requires a<br />
well defined governance mechanism in order to coordinate various changes to the<br />
blockchain, such as the validator set, predefined parameters of the system, as<br />
well as software and wetware protocol upgrades.

All gnut holders are responsible for voting on all proposals. Failing to vote<br />
on a proposal in a timely manner will result in the gnut holder losing<br />
<code>AbsenteeismPenalty</code> (DEFAULT 0.5%) of its gnuts at most once per<br />
<code>AbsenteeismPenaltyWindow</code> (DEFAULT 1 week) time period.

Each proposal requires a deposit of <code>MinimumProposalDeposit</code> tokens, which may<br />
be a combination one or more tokens include gnuts. For each proposal, the voter<br />
may vote to take the deposit. If more than half of the voters choose to take the<br />
deposit (e.g. because the proposal was spam), the deposit goes to the reserve<br />
pool, except any gnuts which are burned.

For each proposal, voters may vote with the following options:

* Yay
* YayWithForce
* Nay
* NayWithForce
* Abstain

A strict majority of Yay or YayWithForce votes (or Nay or NayWithForce votes) is<br />
required for the proposal to be decided as accepted (or decided as failed), but<br />
1/3+ can veto the majority decision by voting with force. When a strict<br />
majority is vetoed, everyone gets punished by losing <code>VetoPenaltyFeeBlocks</code><br />
(DEFAULT 1 day's worth of blocks) worth of fees (except taxes which will not be<br />
affected), and the party that vetoed the majority decision will be additionally<br />
punished by losing <code>VetoPenaltyGnuts</code> (DEFAULT 0.1%) of its gnuts.

=== Parameter Change Proposal ===

Any of the parameters defined here can be changed with the acceptance of<br />
a <code>ParameterChangeProposal</code>.

=== Text Proposal ===

All other proposals, such as a proposal to upgrade the protocol, will be<br />
coordinated via the generic <code>TextProposal</code>.

== Roadmap ==

* Initial validator set
* Shard discovery
* Tendermint V2

== Related Work ==

There have been many innovations in blockchain consensus and scalability in the<br />
past couple of years. This section provides a brief survey of a select number<br />
of important ones.

=== Consensus Systems ===

==== Classic Byzantine Fault Tolerance ====

Consensus in the presence of malicious participants is a problem dating back to<br />
the early 80s, when Leslie Lamport coined the phrase &quot;Byzantine fault&quot; to refer<br />
to arbitrary process behavior that deviates from the intended behavior, in<br />
contrast to a &quot;crash fault&quot;, wherein a process simply crashes. Early solutions<br />
were discovered for synchronous networks where there is an upper bound on<br />
message latency, though pratical use was limited to highly controlled<br />
environments such as airplane controllers and datacenters synchronized via<br />
atomic clocks. It was not until the late 90s that Practical Byzantine Fault<br />
Tolerance (PBFT) was introduced as an efficient asynchronous consensus algorithm<br />
able to tolerate up to ⅓ of processes behaving arbitrarily. PBFT became the<br />
standard algorithm, spawning many variations, including most recently by IBM as<br />
part of their contribution to Hyperledger.

The main benefit of Tendermint consensus over PBFT is that Tendermint has an<br />
improved and simplified underlying structure, some of which is a result of<br />
embracing the blockchain paradigm. Tendermint blocks must commit in order,<br />
which obviates the complexity and communication overhead associated with PBFT's<br />
view-changes. In addition, the batching of transactions into blocks allows for<br />
regular Merkle-hashing of the application state, rather than periodic digests as<br />
with PBFT's checkpointing scheme. This allows for faster provable transaction<br />
commits for light-clients, and as we'll later show, faster inter-blockchain<br />
communication.

==== BitShares delegated stake ====

While not the first to deploy proof-of-stake (PoS), BitShares contributed<br />
considerably to research and adoption of PoS blockchains, particularly those<br />
known as &quot;delegated&quot; PoS. In BitShares, stake holders elect &quot;witnesses&quot;,<br />
responsible for ordering and committing transactions, and &quot;delegates&quot;,<br />
responsible for co-ordinating software updates and parameter changes. Though<br />
BitShares achieves high performance (100k tx/s, 1s latency) in ideal conditions,<br />
it is subject to double spend attacks by malicious witnesses which fork the<br />
blockchain without suffering an explicit economic punishment -- it suffers from<br />
the &quot;nothing-at-stake&quot; problem. BitShares attempts to mitigate the problem by<br />
allowing transactions to refer to recent block-hashes. Additionally,<br />
stakeholders can remove or replace misbehaving witnesses on a daily basis,<br />
though this does nothing to explicitly punish a double-spend attack that was<br />
successful.

==== Stellar ====

Building on an approach pioneered by Ripple, Stellar refined a model of<br />
Federated Byzantine Agreement wherein the processes participating in<br />
consensus do not constitute a fixed and globally known set. Rather, each<br />
process node curates one or more &quot;quorum slices&quot; each constituting a set of<br />
trusted processes. A &quot;quorum&quot; in Stellar is defined to be a set of nodes that<br />
contain (is a superset of) at least one quorum slice for each node in the set,<br />
such that agreement can be reached.

The security of the Stellar mechanism relies on the assumption that the<br />
intersection of ''any'' two quorums is non-empty, while the availability of a node<br />
requires at least one of its quorum slices to consist entirely of correct nodes,<br />
creating a trade-off between using large or small quorum-slices that may be<br />
difficult to balance without imposing significant assumptions about trust.<br />
Ultimately, nodes must somehow choose adequate quorum slices for there to be<br />
sufficient fault-tolerance (or any &quot;intact nodes&quot; at all, of which much of the<br />
results of the paper depend on), and the only provided strategy for ensuring<br />
such a configuration is heirarchical and similar to the Border Gateway Protocol<br />
(BGP), used by top-tier ISPs on the internet to establish global routing tables,<br />
and by that used by browsers to manage TLS certificates; both notorious for<br />
their insecurity.

The criticism in the Stellar paper of the Tendermint-based proof-of-stake<br />
systems is mitigated by the token strategy described here, wherein a new type of<br />
token called the ''gnut'' is issued that (mostly) represents the inherent value of<br />
the network, without competing with any preexisting currency or store of value.<br />
The advantage of Tendermint-based proof-of-stake, then, is its relative<br />
simplicity, while still providing sufficient, and provable security guarantees.

==== BitcoinNG ====

BitcoinNG is a proposed improvement to Bitcoin that would allow for forms of<br />
vertical scalability, such as increasing the block size, without the negative<br />
economic consequences typically associated with such a change, such as the<br />
disproportionately large impact on small miners. This improvement is achieved<br />
by separating leader election from transaction broadcast: leaders are first<br />
elected by proof-of-work in &quot;micro-blocks&quot;, and then able to broadcast<br />
transactions to be committed until a new micro-block is found. This reduces the<br />
bandwidth requirements necessary to win the PoW race, allowing small miners to<br />
more fairly compete, and allowing transactions to be committed more regularly by<br />
the last miner to find a micro-block.

==== Casper ====

Casper is a proposed proof-of-stake consensus algorithm for Ethereum. Its prime<br />
mode of operation is &quot;consensus-by-bet&quot;. The idea is that by letting validators<br />
iteratively bet on which block it believes will become committed into the<br />
blockchain based on the other bets that it's seen so far, finality can be<br />
achieved eventually.<br />
[https://blog.ethereum.org/2015/12/28/understanding-serenity-part-2-casper/ link].<br />
This is an active area of research by the Casper team. The challenge is in<br />
constructing a betting mechanism that can be proven to be an evolutionarily<br />
stable strategy. The main benefit of Casper as compared to Tendermint may be in<br />
offering &quot;availability over consistency&quot; -- consensus does not require a +⅔<br />
quorum from the validators -- perhaps at the cost of commit speed or<br />
implementation complexity.

=== Sharded Scaling ===

==== Interledger Protocol ====

The Interledger protocol is not strictly a scalability solution. It provides an<br />
adhoc interoperation between different ledger systems through a loosely coupled<br />
bilateral relationship network. Like the Lightning Network, the purpose of ILP<br />
is to facilitate payments, but it specifically focuses on payments across<br />
disparate ledger types, and extends the atomic transaction mechanism to include<br />
not only hash-locks, but also a quroum of notaries (called the Universal<br />
Transport Protocol). The latter mechanism for enforcing atomicity in<br />
inter-ledger transactions is similar to Tendermint's light-client SPV echanism,<br />
so an illustration of the distinction between ILP and GnuClear/IBC is warranted,<br />
and provided below.

# The notaries of a connector in ILP does not support membership changes, and<br />
does not allow for flexible weighting between notaries. On the other hand,<br />
IBC is designed specifically for blockchains, where validators can have<br />
different weights, and where membership can change over the course of the<br />
blockchain.
# As in the Lightning Network, the receiver of payment in ILP must online to<br />
send a confirmation back to the sender. In a token transfer over IBC, the<br />
validator-set of the receiver's blockchain is responsible for providing<br />
confirmation, not the receiving user.
# The most striking difference is that ILP's connectors are not responsible or<br />
keeping authoritative state about payments, whereas in GnuClear, the<br />
validators of the GnuClear hub are the authority of the state of IBC token<br />
transfers as well as the authority of the amount of tokens held by each shard<br />
(but not the amount of tokens held by each account within a shard). This is he<br />
fundamental innovation that allows for secure asymmetric tranfer of tokens from<br />
shard to shard; the analog to ILP's connector in GnuClear is a persistent and<br />
maximally secure blockchain ledger.
# The inter-ledger payments in ILP need to be backed by an exchange orderbook,<br />
as there is no asymmetric transfer of coins from one ledger to another, only<br />
the transfer of value or market equivalents.

==== Sidechains ====

Sidechains are a proposed mechanism for scaling the Bitcoin network via<br />
alternative blockchains that are &quot;pegged&quot; to the Bitcoin blockchain. Sidechains<br />
allow bitcoins to effectively move from the Bitcoin blockchain to the sidechain<br />
and back, and allow for experimentation in new features on the sidechain. The<br />
mechanism, known as a two-way peg, uses the standard Simple Payment Verification<br />
(SPV) used by Bitcoin light clients, where proof of a sufficiently long chain of<br />
block headers containing a particular transaction serves as evidence for the<br />
existence of the transaction. Each chain in the peg serves as a light client of<br />
the other, using SPV proofs to determine when coins should be transferred across<br />
the peg and back. Of course, since Bitcoin uses proof-of-work, Bitcoin<br />
sidechains suffer from the many risks of proof-of-work as a consensus mechanism,<br />
which are particularly exacerbated in a scalability context. That said, the core<br />
mechanism of the two-way peg is in principle the same as that employed by the<br />
GnuClear network, though using a consensus algorithm that scales more securely.

==== Ethereum Scalability Efforts ====

Ethereum is currently researching a number of different strategies to shard the<br />
state of the Ethereum blockchain to address scalability needs. These efforts have<br />
the goal of maintaining the abstraction layer offered by the current Ethereum<br />
Virtual Machine across the shared state space. Research efforts are being<br />
conducted by the Ethereum Foundation under Serenity, the Consensus organizations<br />
and the Dfinity project.

=== General Scaling ===

==== Lightning Network ====

The Lightning Network is a proposed message relay network operating at a layer<br />
above the Bitcoin blockchain, enabling many orders of magnitude improvement in<br />
transaction throughput by moving the majority of transactions outside of the<br />
consensus ledger into so-called &quot;payment channels&quot;. This is made possible (with<br />
great difficulty) by the Bitcoin scripting language, which enables parties to<br />
enter into stateful contracts where the state can be updated by sharing digital<br />
signatures, and contracts can be closed by finally publishing evidence onto the<br />
blockchain, a mechanism first popularized by cross-chain atomic swaps. By<br />
openning payment channels with many parties, participants in the Lightning<br />
Network can become focal points for routing the payments of others, leading to a<br />
fully connected payment channel network, at the cost of capital being tied up on<br />
payment channels.

While the Lightning Network can also easily extend across multiple independent<br />
blockchains to allow for the transfer of ''value'' via an exchange market, it<br />
cannot be used to assymetrically transfer ''tokens'' from one blockchain to<br />
another. The main benefit of the GnuClear network described here is to enable<br />
such direct token transfers. That said, we expect payment channels and the<br />
Lightning Network to become widely adopted along with our token transfer<br />
mechanism, for cost-saving and privacy reasons.

==== Segregated Witness ====

Segregated Witness is a Bitcoin improvement proposal<br />
[https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki link] that aims<br />
to increase the per-block tranasction throughput 2X or 3X, while simultaneously<br />
making block syncing faster for new nodes. The brilliance of this solution is<br />
in how it works within the limitations of Bitcoin's current protocol and allows<br />
for a soft-fork upgrade (i.e. clients with older versions of the software will<br />
continue to function after the upgrade). Tendermint being a new protocol has no<br />
design restrictions, so it has a different scaling priorities. Primarily,<br />
Tendermint uses a BFT round-robin algorithm based on cryptographic signatures<br />
instead of mining, which trivially allows horizontal scaling through multiple<br />
parallel blockchains, while regular, more frequent block commits allow for<br />
vertical scaling as well.

<hr/>
== Citations ==

TODO: Link throughout text as appropriate

* Bitcoin: https://bitcoin.org/bitcoin.pdf
* BitcoinNG: https://arxiv.org/pdf/1510.02037v2.pdf
* PBFT: http://pmg.csail.mit.edu/papers/osdi99.pdf
* BitShares: https://bitshares.org/technology/delegated-proof-of-stake-consensus/
* Stellar: https://www.stellar.org/papers/stellar-consensus-protocol.pdf
* Lightning Network: https://lightning.network/lightning-network-paper-DRAFT-0.5.pdf
* Interledger: https://interledger.org/rfcs/0001-interledger-architecture/
* Segregated Witness: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki
* Sidechains: https://blockstream.com/sidechains.pdf
* Casper: https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/
* Tendermint: https://github.com/tendermint/tendermint/wiki
* TMSP: https://github.com/tendermint/tmsp
* Ethereum: http://gavwood.com/paper.pdf
* Ethereum Sharding: https://github.com/ethereum/EIPs/issues/53
* FLP Impossibility: https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf
* https://www.docdroid.net/ec7xGzs/314477721-ethereum-platform-review-opportunities-and-challenges-for-private-and-consortium-blockchains.pdf.html

== Appendix ==

=== Gas Fees for Transactions ===

* IBCBlockCommitTx
* IBCPacketTx
* SendTx
* NewProposalTx
* VoteTx

=== TMSP specification ===

TMSP requests/responses are simple Protobuf messages. Check out the [https://github.com/tendermint/tmsp/blob/master/types/types.proto schema<br />
file].

==== AppendTx ====

* '''Arguments''':
** <code>Data ([]byte)</code>: The request transaction bytes
* '''Returns''':
** <code>Code (uint32)</code>: Response code
** <code>Data ([]byte)</code>: Result bytes, if any
** <code>Log (string)</code>: Debug or error message
* '''Usage''':<br/><br />
Append and run a transaction. If the transaction is valid, returns<br />
CodeType.OK

==== CheckTx ====

* '''Arguments''':
** <code>Data ([]byte)</code>: The request transaction bytes
* '''Returns''':
** <code>Code (uint32)</code>: Response code
** <code>Data ([]byte)</code>: Result bytes, if any
** <code>Log (string)</code>: Debug or error message
* '''Usage''':<br/><br />
Validate a transaction. This message should not mutate the state.<br />
Transactions are first run through CheckTx before broadcast to peers in the<br />
mempool layer.<br />
You can make CheckTx semi-stateful and clear the state upon <code>Commit</code> or<br />
<code>BeginBlock</code>,<br />
to allow for dependent sequences of transactions in the same block.

==== Commit ====

* '''Returns''':
** <code>Data ([]byte)</code>: The Merkle root hash
** <code>Log (string)</code>: Debug or error message
* '''Usage''':<br/><br />
Return a Merkle root hash of the application state.

==== Query ====

* '''Arguments''':
** <code>Data ([]byte)</code>: The query request bytes
* '''Returns''':
** <code>Code (uint32)</code>: Response code
** <code>Data ([]byte)</code>: The query response bytes
** <code>Log (string)</code>: Debug or error message

==== Flush ====

* '''Usage''':<br/><br />
Flush the response queue. Applications that implement <code>types.Application</code><br />
need not implement this message -- it's handled by the project.

==== Info ====

* '''Returns''':
** <code>Data ([]byte)</code>: The info bytes
* '''Usage''':<br/><br />
Return information about the application state. Application specific.

==== SetOption ====

* '''Arguments''':
** <code>Key (string)</code>: Key to set
** <code>Value (string)</code>: Value to set for key
* '''Returns''':
** <code>Log (string)</code>: Debug or error message
* '''Usage''':<br/><br />
Set application options. E.g. Key=&quot;mode&quot;, Value=&quot;mempool&quot; for a mempool<br />
connection, or Key=&quot;mode&quot;, Value=&quot;consensus&quot; for a consensus connection.<br />
Other options are application specific.

==== InitChain ====

* '''Arguments''':
** <code>Validators ([]Validator)</code>: Initial genesis validators
* '''Usage''':<br/><br />
Called once upon genesis

==== BeginBlock ====

* '''Arguments''':
** <code>Height (uint64)</code>: The block height that is starting
* '''Usage''':<br/><br />
Signals the beginning of a new block. Called prior to any AppendTxs.

==== EndBlock ====

* '''Arguments''':
** <code>Height (uint64)</code>: The block height that ended
* '''Returns''':
** <code>Validators ([]Validator)</code>: Changed validators with new voting powers (0<br />
to remove)
* '''Usage''':<br/><br />
Signals the end of a block. Called prior to each Commit after all<br />
transactions

=== Merkle tree &amp; proof specification ===

* SimpleTree
* IAVLTree
* Proof Expression langauge

== Acknowledgements ==

We thank our friends and peers for assistance in conceptualizing, reviewing, and<br />
providing support for our work with Tendermint and GnuClear.

* [https://github.com/zmanian Zaki Manian] of<br />
[https://www.skuchain.com/ SkuChain] provided much help in formatting and<br />
wording, especially under the TMSP section.
* [https://github.com/jtremback Jehan Tremback] of Althea and Dustin Byington<br />
for helping with initial iterations
* Also thanks to [https://github.com/gleim Bill Gleim] for various<br />
contributions.
* TODO Your name and organization here if you want.

